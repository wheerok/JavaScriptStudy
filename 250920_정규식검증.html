<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="main.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
</head>
<body>
     <div class="black-bg">
        <div class="white-bg">
            <h4>로그인하세요</h4>

            <form action="success.html" id="loginForm"> <!--서버로 -->
                <div class="my-3">
                    <input type="text" class="form-control" id="email">
                </div>
                <div class="my-3">
                    <input type="password" class="form-control" id="password">
                </div>
                <button type="submit" class="btn btn-primary" id="send">전송</button>
                <button type="button" class="btn btn-danger" id="close">닫기</button>
                </form> 
        </div>
    </div> 

    <div class="main-bg">
        <h4>Shirts on Sale</h4>
        <button id="login" class="btn btn-danger">로그인</button>
    </div>

     <script>
        if (1 == 3){
            console.log('맞아요1');
        } else if(3 == 3){
            console.log('맞아요2');
        }
         // 앞의 조건식이  참이면 else문 뒤에는 실행 X

        $('#login').on('click', function(){
            $('.black-bg').fadeIn();
        });
        $('#close').on('click', function(){
            $('.black-bg').fadeOut();
        });


        //전송버튼 누르면, 인풋에 입력한 값이 공백이면 알림창 띄우기
        /*document.getElementById('loginForm').addEventListener('submit', function(e){
            if ( document.querySelectorAll("input")[0].value == ""){
                e.preventDefault();
                //참이면 실행할 코드
                alert('이메일을 입력해주세요.');
            } else{
                //참이 아니면 실행할 코드
                alert('환영합니다!');
            }
        });*/

        /*$('form').on('submit', function(e){
            if($('form #email').val() == ""){
                e.preventDefault();
                alert('이메일을 입력하세요!');
            } else {
                alert('환영합니다!');
            }
        });*/
        

        $('form').on('submit', function(e){
            var userInputId = document.getElementById('email').value;
            var userIputPsw = document.getElementById('password').value;
            //form 검증 시에는 return으로 끊어주는 방식이 깔끔함

            //이메일 입력 여부 검사
            if(userInputId == ""){
                e.preventDefault();
                alert('이메일을 입력하세요!');
                return; 
            }
            
            //이메일 형식 검사
            if(!/\S+@\S+\.\S+/.test(userInputId)){
                e.preventDefault();
                alert('이메일 형식인지 확인해주세요!');
                return;
            }
            //비밀번호 입력 여부 검사
            if(userIputPsw == ""){
                e.preventDefault();
                alert('비밀번호를 입력하세요!');
                return;
            }

            //비밀번호 영어 대문자 입력 여부 검사
            if(!/[A-Z]/.test(userIputPsw)){
                // !를 붙이면 not 즉, 이 정규식이 아니라면
                e.preventDefault();
                alert('비밀번호에 영어 대문자를 1개 이상 입력하세요!')
                return;
            }

            /*
                일반적으로 요즘엔 보안 때문에 대문자 + 특문 + 숫자가 모두 들어가야 하는데 이럴 경우엔
                !/[A-Z]/.test(...) && !/[!@_]/,test(...) && !/[0-9]/.test(...)
                -> 이렇게 조건이 붙어야 할 듯

                근데 너무 기니까... 
                정규식의 lookahead 기능을 쓰면 한 줄로 검사가 가능함
                !/^(?=.*[A-Z])(?=.*[!@_])(?=.*[0-9])/.test(...)
                -> 다 만족해야만 함

                (?=.*[A-Z]) : 문자열 어딘가에 영어 대문자가 최소 1개 존재
                (?=.*[!@_]) : 문자열 어딘가에 특수문자 !,@,_ 중 최소 하나가 1개 존재
                ^... : 문자열의 처음부터 검사 시작

                ?=.* 은 긍정형 전방탐색(positive lookahead)이라는 기능임
                (?= ... ) : 이 안의 조건이 [앞으로 이어지는 문자열 어딘가에 반드시] 있어야 한다
                . : 아무글자 하나
                * : 0개 이상 반복

                /^(?=.*[A-Z])/.test('Hello') 
                이건 lookahead → “앞으로 가면서 대문자가 하나라도 있는지 확인”
                하지만 확인만 할 뿐, 실제 문자를 매칭하지는 않음 → 즉, 소모하지 않는다
                ->"Hello" 안에서 대문자 H를 “있네” 하고 체크만 하고, H를 잡아먹지 않고 그대로 둠

                BUT

                [A-Z]
                이건 대문자 하나를 실제로 매칭함
                -> "Hello"에서 매칭하면 H를 실제로 잡아먹고, 다음 검사 위치는 e부터 시작

                /^(?=.*[A-Z])(?=.*[!@_])(?=.*[0-9])/ 도 정상적으로 작동하지만
                문자열 전체가 규칙에 맞는지 보장하려면  .+$가 붙어야 함

                따라서 문자열 전체가 규칙에 맞는지를 보장하려면 마지막에 .+$ 같은 실제 매칭 패턴이 필요함
                /^(?=.*[A-Z])(?=.*[!@_])(?=.*[0-9]){6,}.+$/

                즉, lookahead (?=...) → 조건 확인만 하고, 글자를 소비하지 않음
                보통 패턴([A-Z], .+ 등) → 글자를 실제로 매칭하면서 소비함

                그래서 내가 이해한 것은 더 공고화(확실하게) 하려는 목적...

                조건 + 실제 문자열이 최소 1글자 이상 있는 것까지 보장.
                -> “비밀번호” 같은 보안 조건을 검증할 땐 보통 .+$ 또는 .{8,}$ 같은 최소 길이 제약을 붙여서 더 안전하게 쓸 수 있음


                반약 2개 이상~ 포함되어야 한다면
                /^(?=(?:.*[!@_]){n,})/
                -> 정규식에서 {} 는 “반복 횟수”를 지정하는 수량자(quantifier)

                {n} → 정확히 n번 반복
                {n,m} → 최소 n번, 최대 m번 반복
                {n,} → 최소 n번 이상 (최대는 제한 없음)

                여기서 쓰인 {2,}은? 최소 2번 이상 반복을 뜻함 뒤에 최대값이 비어 있으니까 “2 이상은 얼마든지”라는 의미

                대문자가 최소 1개 이상, 특수문자가가 !@_ 중 최소 1개 이상, 숫자는 6개가 조건이라면
                /^(?=.*[A-Z])(?=.*[!@_])(?=(?:.*[0-9]){6,}).+$/

                . : 아무글자 하나
                * : 0개 이상 반복

                (?=(?:.*[0-9]){6,}) 해석하기

                [0-9]
                👉 0부터 9까지 숫자 1개

                .*[0-9]
                👉 “아무 글자(.*) 뒤에 숫자 1개” → 즉, 숫자 하나 찾기

                (?: ... ){6,}
                👉 괄호 안 내용을 6번 이상 반복
                → 즉, “숫자 하나 찾기”를 6번 이상 반복해야 함
                → 숫자가 6개 이상 있어야 한다

                (?= ... )
                👉 “앞으로 보니까 이런 조건이 있어야 해!” → 조건만 확인, 실제로 글자를 가져가진 않음 (개수만 확인하면 되니까)
            */
            
            //비밀번호 자릿수 검사
            if(userIputPsw.length < 6){
                e.preventDefault();
                alert('비밀번호를 6자 이상 입력하세요!');
                return;
            }
            
            alert('환영합니다!');
           
        });

        document.getElementById('email').addEventListener('change', function(){
            //document.getElementById('email') 여기에 유저가 입력한 값이 변할 때마다 실행 (계속 검사)
            //change도 있음 -> 유저가 값을 입력 후 포커스를 잃을 때 실행 
            console.log('값이 입력되었어~');
        });

        
        /*
            문자를 검사하는 가장 쉬운 방법
            '문자'.includes('찾을 단어')
            -> 아무 문자 뒤에 .includes()를 붙일 수 있음
            -> 그러면 찾을 단어가 들어있늕디 검사하고 true, false 반환
            ⛔️ 하지만 한글이냐, 영어냐, A로 끝나냐 마침표 다음에 영어가 있냐 등은 검사가 어려움
            ==================================================================

            그래서 사용하는 것이 '정규표현식(regular expression)'
            정규식 표현법은? /abc/이게 끝임 그럼 물어볼 준비 완료!

            abcdef라는 문자에 abc라는 단어가 있는지 검사하는 방법
            /abc/.test('abcdef')

            ❇️ /정규식/.test(정규식으로 검사할 문자)
            -> 그러면 검사하고 true, false 반환

            ==================================================================
            
            🔆정규식 문법 배워보기

            (1)
            /a/.test('abcdef') -> true
            영어나 한글의 경우 그냥 쓰면 글자가 유무를 물어볼 수 있음

            (2)
            /[a-b]/.test('aefg') // true
             /[가-다].test('다라마바') //true
            []기호를 이용해서 문자 범위 지정 가능함
            즉, [a-z]는 a부터 z까지 아무 문자 하나를 의미함

            (3)
            /[a-zA-z]/.test('반가워요') //flase -> 아무 알파벳 하나
            /[a-zA-Z]/.test('반가워요a') //true
            /[ㄱ-ㅎ가-힣ㅏ-ㅑ]/.test('반가워요') //true -> 아무 한글 하나

            (4)
            /\S/.test('abcde') // true
            백슬래시S는 특수문자 포함 아무 문자 1개라는 뜻


            (5)
            /^a/.test('abcde') //true -> a로 시작하는지 검사
            /a$/.test('abcde') //true -> e로 끝나는지 검사

            (6) /(e|f)/.text('abcde') //true
            or로 e나 f 중 한 문자라도 있는지 검사를 함
            정규식에서도 괄호 사용 가능

            (7)/a+/
            + 기호를 붙여주면 뒤에 오는 글자들도 a와 일치하먄 반복해서 쭉 찾아달라는 뜻
            /a/는 a를 다 찾는 게 아니라 a 한 개를 찾으라는 뜻이기 때문임
            aaaaa 이런 거를 찾고 싶으면 /a+/ 쓰기

            ** /\S+t/ : 모든 문자 여러개 다음에 t라는 글자가 있는지 검사하라는 정규식임
            -> aaaat bbt 이런 것을을 찾아줄 듯
        */

    </script>

</body>
</html>